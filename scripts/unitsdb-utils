#!/usr/bin/env ruby

require "thor"
require "yaml"

module Unitsdb
  class UtilsCommand < Thor
    DEFAULT_YAML_FILES = %w[dimensions prefixes quantities unit_systems units].map { |f| "#{f}.yaml" }

    desc "check_uniqueness [INPUT]", "Check for uniqueness of 'short' and 'id' fields in a YAML file or all YAML files with --all"
    method_option :all, type: :boolean, default: false, aliases: "-a", desc: "Check all YAML files in the repository"
    method_option :dir, type: :string, default: ".", aliases: "-d", desc: "Directory containing the YAML files"

    def check_uniqueness(input=nil)
      if options[:all]
        check_yaml_files(DEFAULT_YAML_FILES.map { |f| File.join(options[:dir], f) })
      elsif input
        check_yaml_files([input])
      else
        puts "Error: INPUT file is required when not using --all"
        exit(1)
      end
    end

    desc "normalize [INPUT] [OUTPUT]", "Normalize a YAML file or all YAML files with --all"
    method_option :sort, type: :boolean, default: true, desc: "Sort keys alphabetically"
    method_option :all, type: :boolean, default: false, aliases: "-a", desc: "Normalize all YAML files in the repository"
    method_option :dir, type: :string, default: ".", aliases: "-d", desc: "Directory containing the YAML files"

    def normalize(input=nil, output=nil)
      unless options[:all] || (input && output)
        puts "Error: INPUT and OUTPUT are required when not using --all"
        exit(1)
      end

      if options[:all]
        DEFAULT_YAML_FILES.each do |file|
          path = File.join(options[:dir], file)
          next unless File.exist?(path)
          normalize_file(path, path)
          puts "Normalized #{path}"
        end
        puts "All YAML files normalized successfully!"
      end

      if input && output
        normalize_file(input, output)
        puts "Normalized YAML written to #{output}"
      end
    end

    private

    def check_yaml_files(files)
      all_dups = { short: {}, id: {} }

      files.each do |file_path|
        next unless File.exist?(file_path)

        file_type = File.basename(file_path, ".yaml")
        yaml = YAML.safe_load(File.read(file_path))

        # Find duplicates
        find_duplicates(yaml, file_type, all_dups)
        puts "Checked #{file_path}"
      end

      # Display results
      display_results(all_dups)
    end

    def find_duplicates(yaml, file_type, all_dups)
      # Find 'short' duplicates
      shorts = {}
      yaml.each do |key, value|
        next unless value.is_a?(Hash) && value.key?("short")
        (shorts[value["short"]] ||= []) << key
      end

      # Add to results if duplicates found
      shorts.each do |short, paths|
        next unless paths.size > 1
        (all_dups[:short][file_type] ||= {})[short] = paths
      end

      # Find 'id' duplicates
      ids = {}
      yaml.each do |key, value|
        next unless value.is_a?(Hash)
        scan_for_ids(key, value, "", ids)
      end

      # Add duplicates to results
      ids.each do |id, paths|
        next unless paths.size > 1
        (all_dups[:id][file_type] ||= {})[id] = paths
      end
    end

    def scan_for_ids(root, obj, path, ids)
      case obj
      when Hash
        # Check for si_derived_bases path
        return if path == "si_derived_bases" || path.end_with?(".si_derived_bases")

        # Record ID if present
        if obj.key?("id")
          id = obj["id"]
          loc = path.empty? ? root : "#{root}:#{path}"
          (ids[id] ||= []) << loc
        end

        # Process hash entries
        obj.each do |k, v|
          new_path = path.empty? ? k.to_s : "#{path}.#{k}"
          scan_for_ids(root, v, new_path, ids)
        end
      when Array
        # Skip if this is inside si_derived_bases
        return if path == "si_derived_bases" || path.end_with?(".si_derived_bases")

        # Process array elements with indices
        obj.each_with_index do |item, idx|
          next unless item.is_a?(Hash) || item.is_a?(Array)

          if item.is_a?(Hash) && item.key?("id")
            parent = path.empty? ? root : "#{root}:#{path}"
            (ids[item["id"]] ||= []) << "#{parent}[#{idx}]"
          else
            new_path = path.empty? ? idx.to_s : "#{path}.#{idx}"
            scan_for_ids(root, item, new_path, ids)
          end
        end
      end
    end

    def display_results(all_dups)
      [:short, :id].each do |type|
        dups = all_dups[type]
        if dups.empty?
          puts "No duplicate '#{type}' fields found."
          next
        end

        puts "\nFound duplicate '#{type}' fields:"
        dups.each do |file, items|
          puts "  #{file}.yaml:"
          items.each do |val, paths|
            puts "    '#{val}':"
            paths.each { |p| puts "      - #{p}" }
          end
        end
      end
    end

    def normalize_file(input, output)
      yaml = YAML.safe_load(File.read(input))
      yaml = sort_yaml_keys(yaml) if options[:sort]
      File.write(output, yaml.to_yaml)
    end

    def sort_yaml_keys(obj)
      case obj
      when Hash
        # Transform values first, then sort keys
        obj.transform_values { |v| sort_yaml_keys(v) }
           .sort_by do |key, _|
             key_str = key.to_s

             # Handle NIST IDs for prefixes to sort negative powers first
             if key_str =~ /^NIST([a-z])(\d+)_(-?\d+)/
               [$1, $2.to_i, $3.to_i]
             elsif key_str =~ /^NIST([a-z])(\d+)/
               [$1, $2.to_i, 0]  # Fallback for keys without underscore
             else
               [key_str]
             end
           end.to_h
      when Array
        obj.map { |item| sort_yaml_keys(item) }
      else
        obj
      end
    end
  end
end

Unitsdb::UtilsCommand.start(ARGV)
